import json
import os
import sys
import tiktoken

import openai

def print_red(text):
    print(f'\033[91m{text}\033[0m')

def print_green(text):
    print(f'\033[92m{text}\033[0m')

def query_llm(json_data, original_code, all_reasons):
    prompt = f'''
Given the following C code:
```c
{original_code}
```
The following code is generated by a tool that translates C code to Rust code. The tool has a bug that causes it to generate incorrect Rust code. The bug is related to the following error message:
```json
{json_data}
```
Please analyze the error message and provide a reason why the tool generated incorrect Rust code.
'''
    if all_reasons:
        prompt += f'''
You have 2 options to choose from:
1. Append a new reason to the list of reasons.
2. Select a reason from the list of reasons that best describes the error message.

Please provide a reason why the tool generated incorrect Rust code **FUNDAMENTALLY**.
'''
        prompt += f'''
List of reasons:
'''
        for i in range(len(all_reasons)):
            prompt += f'{i + 1}. {all_reasons[i]}\n'
    else:
        prompt += f'''
Please provide a reason why the tool generated incorrect Rust code **FUNDAMENTALLY**.
Note that you can not make "select" action because there are no reasons to select from.
'''
    prompt += '''
Please provide the analysis output in the following format:
```json
{
    "action": "append", // or "select" to select a reason from the list of reasons
    "reason": "Format string differences between C and Rust", // the reason for the error message, if action is "append"
    "selection": 1 // the index of the reason from the list of reasons, if action is "select"
    // "reason" and "selection" are mutually exclusive, you should only provide one of them
}
```

Please **make sure** to provide a general reason that can be applied to multiple cases, not a specific reason that only applies to the current case.
Please provide a reason why the tool generated incorrect Rust code **FUNDAMENTALLY** (NOTE that the reason of first failure is always NOT the fundamental reason).
'''
    client = openai.Client(
        api_key = "***REMOVED***",  # Replace with your actual API key
        # base_url = "https://api.deepseek.com",  # Replace with your actual base URL
    )

    print_red(prompt)
    response = client.chat.completions.create(
        model = "accounts/fireworks/models/deepseek-r1",
        messages=[
            {"role": "system", "content": "You are a software engineer who is analyzing a bug in a code translation tool."},
            {"role": "user", "content": prompt},
        ],
        max_tokens=16384,
    )

    resp_text = response.choices[0].message.content
    print_green(resp_text)
    start = False
    json_data = ''
    for line in resp_text.split('\n'):
        if line.find('```json') != -1:
            start = True
            continue
        if start:
            if line.find('```') != -1:
                break
            json_data += line + '\n'

    return json.loads(json_data)


target_dir = sys.argv[1]
idiomaticy = sys.argv[2]
reason_file = sys.argv[3]
model = target_dir.split('/')[0].split('_')[-1]
cases = os.listdir(target_dir)
all_reasons_file = f'all_reasons.json'

enc = tiktoken.encoding_for_model("gpt-4o")

if not os.path.exists(all_reasons_file):
    with open(all_reasons_file, 'w') as f:
        f.write('[]')

with open(all_reasons_file, 'r') as f:
    all_reasons = json.load(f)

if os.path.exists(reason_file):
    with open(reason_file, 'r') as f:
        reasons = json.load(f)

for case in cases:
    idiomaticy_failure_json = os.path.join(
        target_dir, case, f'{idiomaticy}_failure_info.json')
    if not os.path.exists(idiomaticy_failure_json) \
            and os.path.exists(idiomaticy_failure_json.replace('matic', '')):
        idiomaticy_failure_json = idiomaticy_failure_json.replace('matic', '')

    combined_code = os.path.join(target_dir, case, f'translated_code_{idiomaticy}', 'combined.rs')
    f_filled_code = os.path.join(target_dir, case, f'translated_code_{idiomaticy}', 'functions', 'f_filled.rs')
    if os.path.exists(combined_code) or os.path.exists(f_filled_code):
        continue

    code_path = os.path.join(os.path.dirname(target_dir), 'selected_data', case)
    if not os.path.exists(code_path):
        code_path = os.path.join(os.path.dirname(os.path.dirname(target_dir)), 'selected_data', 'argv', case)

    if not os.path.exists(reason_file):
        reasons = {}
    else:
        with open(reason_file, 'r') as f:
            reasons = json.load(f)

    # if a reason is already in all_reasons, add it to reasons
    for r in all_reasons:
        if r in reasons:
            continue
        reasons[r] = []
    # if a reason is in reasons but not in all_reasons, add it to all_reasons
    for r in reasons:
        if r in all_reasons:
            continue
        all_reasons.append(r)


    with open(all_reasons_file, 'w') as f:
        json.dump(all_reasons, f, indent=4)

    skip = False
    for k, v in reasons.items():
        if case in v:
            skip = True
    if skip:
        continue

    if os.path.exists(idiomaticy_failure_json):
        print(f'Analyzing {case}...')
        with open(idiomaticy_failure_json, 'r') as f:
            idiomaticy_failure_info = json.load(f)
        with open(code_path, 'r') as f:
            code = f.read()
        errs_arr = {}
        for k, v in idiomaticy_failure_info.items():
            errs = v['errors']
            if len(errs) < 3:
                continue
            errs_arr[k] = errs

        err_str = json.dumps(errs_arr)
        token_count = len(enc.encode(err_str))
        print(token_count)
        if token_count > 16384:
            cut_point = (len(err_str) // token_count) * 16384
            err_str = err_str[:cut_point]
        result = query_llm(err_str, code, all_reasons)
        if 'reason' in result:
            reasons[result['reason']] = [case]
        elif 'selection' in result:
            reasons[all_reasons[result['selection'] - 1]].append(case)

        with open(reason_file, 'w') as f:
            json.dump(reasons, f, indent=4)


with open(reason_file, 'r') as f:
    reasons = json.load(f)
count = 0
for k, v in reasons.items():
    count += len(v)
print(f'{count} cases analyzed.')
